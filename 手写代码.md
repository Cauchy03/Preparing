## 实现寄生组合继承

**`Object.create()`** 方法用于创建一个新对象，使用现有的对象来作为新创建对象的原型（prototype）

定义Super和Sub构造函数

```js
function Super() {
    this.name = true
}
Super.prototype.say = function () {
    console.log('这是Super的say函数');
}
function Sub() {
    // 使调用的Super构造函数的this指向当前Sub构造函数的this
    Super.call(this)
}
// Sub.prototype = new Super()  // 组合继承方式

// 寄生组合继承 采用Object.create()
// 创建一个新对象，使用现有的对象来作为新创建对象的原型
// 将Sub的原型改为Super的原型
Sub.prototype = Object.create(Super.prototype)
const sub = new Sub()
console.log(sub)
sub.say()
```

## 手写instanceof

`instanceof` 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。

```js
function myInstanceof(left, right) {
  // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
  // 相当于实例对象.__proto__
  let proto = Object.getPrototypeOf(left)
  // 获取构造函数的 prototype 对象
  let prototype = right.prototype; 
 
  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;
    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型
    proto = Object.getPrototypeOf(proto);
  }
}
```

## 手写new关键字

**new操作符的执行过程：**

（1）首先创建了一个新的空对象

（2）设置原型，将对象的原型设置为函数的 prototype 对象。

（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）

（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。

具体实现：

```js
function objectFactory() {
  let newObject = null;
  let constructor = Array.prototype.shift.call(arguments);
  let result = null;
  // 判断参数是否是一个函数
  if (typeof constructor !== "function") {
    console.error("type error");
    return;
  }
  // 新建一个空对象，对象的原型为构造函数的 prototype 对象
  newObject = Object.create(constructor.prototype);
  // 将 this 指向新建对象，并执行函数
  result = constructor.apply(newObject, arguments);
  // 判断返回对象
  let flag = result && (typeof result === "object" || typeof result === "function");
  // 判断返回结果
  return flag ? result : newObject;
}
// 使用方法
objectFactory(构造函数, 初始化参数);
```

```js
function mynew(Func, ...args) {
    // 1.创建一个新对象
    const obj = {}
    // 2.新对象原型指向构造函数原型对象
    // obj.__proto__ = Func.prototype
    obj = Object.craete(Func.prototype)
    // 3.将构建函数的this指向新对象
    let result = Func.apply(obj, args)
    // 4.根据返回值判断
    return result instanceof Object ? result : obj
}
```

## 手写call，apply，bind

​	**（1）call 函数的实现步骤：**

- 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
- 判断传入上下文对象是否存在，如果不存在，则设置为 window 。
- 处理传入的参数，截取第一个参数后的所有参数。
- 将函数作为上下文对象的一个属性。
- 使用上下文对象来调用这个方法，并保存返回结果。
- 删除刚才新增的属性。
- 返回结果。

```js
Function.prototype.myCall = function(context) {
  // 判断调用对象
  if (typeof this !== "function") {
    console.error("type error");
  }
  // 获取参数
  let args = [...arguments].slice(1),
  result = null;
  // 判断 context 是否传入，如果未传入则设置为 window
  context = context || window;
  // 将调用函数设为对象的方法
  context.fn = this;
  // 调用函数
  result = context.fn(...args);
  // 将属性删除
  delete context.fn;
  return result;
}
```

**（2）apply 函数的实现步骤：**

- 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
- 判断传入上下文对象是否存在，如果不存在，则设置为 window 。
- 将函数作为上下文对象的一个属性。
- 判断参数值是否传入
- 使用上下文对象来调用这个方法，并保存返回结果。
- 删除刚才新增的属性
- 返回结果

```js
Function.prototype.myApply = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  let result = null;
  // 判断 context 是否存在，如果未传入则为 window
  context = context || window;
  // 将函数设为对象的方法
  context.fn = this;
  // 调用方法
  if (arguments[1]) {
    result = context.fn(...arguments[1]);
  } else {
    result = context.fn();
  }
  // 将属性删除
  delete context.fn;
  return result;
};
```

**（3）bind 函数的实现步骤：**

**后面传入的也是一个参数列表(但是这个参数列表可以分多次传入)**

- 判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。
- 保存当前函数的引用，获取其余传入参数值。
- 创建一个函数返回
- 函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。

```js
Function.prototype.myBind = function(context) {
  // 判断调用对象是否为函数
  if (typeof this !== "function") {
    throw new TypeError("Error");
  }
  // 获取参数
  var args = [...arguments].slice(1),
    fn = this;
  return function Fn() {
    // 根据调用方式，传入不同绑定值
    return fn.apply(
      this instanceof Fn ? this : context,
      args.concat(...arguments)
    );
  };
};
```

## 手写深拷贝

```js
// 手写深拷贝
function deepClone(obj) {
    if (!obj || typeof obj !== "object") return obj
    let newObj = obj instanceof Array ? [] : {}
    for (const key in obj) {
        if (Object.hasOwnProperty.call(obj, key)) {
            newObj[key] = deepClone(obj[key])
        }
    }
    return newObj
}
```

## JSON.stringify、JSON.parse处理

```js
// 对象序列化，undefined和函数丢失问题
const JSONStringify = (option) => {
    return JSON.stringify(option,(key, val) => {
        // 处理函数丢失问题
        if (typeof val === 'function') {
            return `${val}`;
        }
        // 处理undefined丢失问题
        if (typeof val === 'undefined') {
            return 'undefined';
        }
        return val;
    },2)
},
    // 对象序列化解析
const JSONParse = (objStr) => {
        return JSON.parse(objStr, (k, v) => {
            if (typeof v === 'string' && v.indexOf && v.indexOf('function') > -1) {
                // eval 可能在eslint中报错，需要加入下行注释
                // eslint-disable-next-line
                return eval(`(function(){return ${v}})()`);
            }
            return v;
        });
    }
```

## 手写防抖和节流

频繁触发事件导致的性能问题

防抖：触发事件n秒后执行函数，如果n秒内又触发该事件，则会重新计算执行时间

```js
// 防抖
function myDebounce(fn, delay) {
    let timer = null
    return function () {
        // 保存this指向和传入参数
        let context = this
        let args = arguments
        if (timer) {
            // 如果此时存在定时器的话，则取消之前的定时器重新记时
            clearTimeout(timer)
            timer = null
        }
        // 设置定时器，使事件间隔指定事件后执行
        timer = setTimeout(() => {
            fn.apply(context, args)
        }, delay)
    }
}
```

节流：连续触发事件但是n秒内只执行一次函数。即不管在指定事件内触发多少次函数，都只执行一次事件

```js
 // 节流
function myThrottle(fn, delay) {
    // 改变量用于记录上一次函数的执行时间
    let lastTime = 0
    return function () {
        // 保存this指向和传入参数
        let context = this
        let args = arguments
        // 获取当前时间
        let nowTime = Date.now()
        // 剩余时间大于时间间隔，才能执行函数
        if (nowTime - lastTime >= delay) {
            fn.apply(context, args);
            // 将上一次函数执行的时间设置为nowTime，这样下一次才能重新进入cd
            lastTime = nowTime
        }
    }
}
```

## 实现数据类型判断

```js
function checkType(obj) {
    return Object.prototype.toString.call(obj).slice(8, -1)
}
```

## 实现函数柯里化

```js
function curry(fn, args) {
    // 获取函数fn的参数长度
    let length = fn.length
    args = args || []
    return function () {
        // 这里的arguments是返回函数传入的参数
        // 拼接参数
        let subArgs = args.concat(Array.prototype.slice.call(arguments))
        // 判断参数的长度是否满足函数所需参数长度
        if (subArgs.length >= length) {
            // 如果满足，执行函数,返回执行的结果
            return fn.apply(this, subArgs)
        } else {
            // this window
            // 如果不满足，递归返回柯里化函数，等待参数的传入
            return curry.call(this, fn, subArgs)
        }
    }
}
```

```js
// ES6语法
function curry(fn, ...args) {
    return args.length >= fn.length ? fn(...args) : curry.bind(null, fn, ...args)
}
```

## 实现ajax请求

```js
SERVER_URL = "/server"
let xhr = new XMLHttpRequest()
// 创建http请求 第三个参数表示异步
xhr.open('GET', SERVER_URL, true) // xhr.open('POST', SERVER_URL)
// 设置超时时间 
xhr.timeout = 3000
xhr.addEventListener('timeout', () => {
    console.log('时间超时')
})
// 监听请求进度
xhr.addEventListener('progress', (event) => {
    console.log(event.loaded, event.total, (event.loaded/event.total * 100).toFixed(2))
})
// 设置监听函数，相当于拦截器
xhr.onreadstatechange = function () {
    // readyState 0: 未初始化，XMLHttpRequest对象创建，但未调用open方法
    // readyState 1: 已打开open，send未调用
    // readyState 2: send调用，服务器接收请求
    // readyState 3: 服务器正在接收请求并返回数据
    // readyState 4: 完成数据传输
    if (this.readyState !== 4) return
    // 当请求成功时
    if (this.status === 200) {
        handle(this.response)
    } else {
        console.err(this.statusText);
    }
}
// 监听函数 相当于onreadstatechange
// xhr.onload = function () {
//     if (this.status === 200) {
//         handle(this.response)
//     } else {
//         console.err(this.statusText);
//     }
// }

// 请求时失败时的监听函数
xhr.onerror = function () {
    console.error(this.statusText);
}
// 设置请求头
// xhr.responseType = 'json'
// xhr.setRequestHeader('Accept', 'application/json')
// xhr.setRequestHeader('Accept', 'application/x-www-form-urlencoded')

// 中断请求
// xhr.abort()

// 发送请求
xhr.send()
```

```js
// 上传文件
const formData = new FormData()
// input file上传后的文件是一个lists 取数组第一个
formData.append('file', file.files[0])
const xhr = new XMLHttpRequest()
xhr.open('post', '...url', true)
xhr.setRequestHeader('Accept', 'multipart/form-data')
xhr.send(formDada)
// FormData对象有一个特点，将文件信息添加进去后，直接打印不能看到文件信息，需要使用for of遍历才能看到
for (const v of formData) {
    console.log(v)
}
// 从FormData对象中删除一个数据
// formdata.delete(key)
```

## 实现fetch

```js
// 用于中断请求
const myAbort = new AbortController()
// myAbort.abort() 中断请求

// 超时 利用setTimeout
setTimeout(() => {
    myAbort.abort()
}, 3000)

// text() 将响应体解析为纯文本字符串并返回
// json() 将响应体解析为JSON对象
// blob() 解析为二进制数据并返回Blob对象
// arrayBuffer() 解析为二进制数据并返回arrayBuffer对象
// formData() 解析为formData对象
fetch('url...', {
    method: 'post', // 默认get
    headers: {
        'Content-Type': 'application/json'
    },
    body: JSON.stringify({...}),
    signal: myAbort.signal // 添加属性后 可以调用myAbort的abort方法中断请求
                         }).then(res => {
        // 拷贝一份res用于返回
        const response = res.clone()
        // 获取当前进度
        const reader = res.body.getReader() // 返回一个流
        // 获取返回数据的总长度
        const total = res.headers.get('Content-Length')
        let loaded = 0
        while(true) {
            // done 如果为true数据接收完
            // value 返回一个buffer流
            const { done, value } = await reader.read()
            if(done) { break }
            loaded += value.length // 当前进度
            console.log((loaded / total * 100).toFixed(2))
        }
        return response.json()
    }).then(data => {
        console.log(data)
    })
```

## 实现数组扁平化

```js
// 普通递归扁平化
function flatten(arr) {
    let result = []
    for (let i = 0; i < arr.length; i++) {
        // 如果当前元素是一个数组，对其进行递归展平
        if (Array.isArray(arr[i])) {
            // 递归展平结果拼接到结果数组
            // result = result.concat(flatten(arr[i]))
            result = [...result, ...flatten(arr[i])]
        } else {
            result.push(arr[i])
        }
    }
    return result
}
```

```js
// reduce实现
function flatten(arr) {
    return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur)
    }, [])
}
```

```js
// 扩展运算符实现
function flatten(arr) {
    while (arr.some(item => Array.isArray(item))) {
        arr = [].concat(...arr)
    }
    return arr
}
```

```js
// toString和split实现
function flatten(arr) {
    return arr.toString().split(',').map(item => Number(item))
}
```

## 实现数组去重

```js
// Set实现
Array.from(new Set(arr))
```

```js
// 使用map存储不重复的数字
function uniqueArray(arr) {
    let map = new Map()
    let newArr = []
    arr.forEach(item => {
        // has()用于判断map是否包含为item的属性值
        if (!map.has(item)) {
            // 使用set()将item设置到map中，并设置其属性值为true
            map.set(item, true)
            newArr.push(item)
        }
    })
    return newArr
}
```

```js
// 使用indexOf()
function uniqueArray(arr) {
    let newArr = []
    arr.forEach(item => {
        if (newArr.indexOf(item) === -1) {
            newArr.push(item)
        }
    })
    return newArr
}
```

```js
// 使用includes()
function uniqueArray(arr) {
    let newArr = []
    arr.forEach(item => {
        if (!newArr.includes(item)) {
            newArr.push(item)
        }
    })
    return newArr
}
```

**对象数组去重：**



## 实现斐波那契数列

```js
// n 是斐波那契数列的第n项

// 递归
function fibonacci(n) {
    if (n <= 2) return 1
    return fibonacci(n - 2) + fibonacci(n - 1)
}
```

```js
// 非递归
function fibonacci(n) {
    let pre1 = 1
    let pre2 = 1
    let current = 2
    if (n <= 2) return 1
    for (let i = 2; i < n; i++) {
        current = pre1 + pre2
        pre1 = pre2
        pre2 = current
    }
    return current
}
```

## 实现发布订阅模式

```js
class Observer {
    constructor() {
        this.message = {} // 消息队列
    }

    // 添加事件
    on(type, callback) {
        // 先判断有没有这个属性（事件类型）
        if (!this.message[type]) {
            // 如果没有这个属性，就初始化一个空的数组
            this.message[type] = []
        }
        // 如果有这个属性，就往他的后面push一个新的 callback
        this.message[type].push(callback)
    }

    // 事件触发
    emit(type, ...params) {
        // 判断是否有订阅
        if (!this.message[type]) return
        // 如果有订阅，就对这个type事件做一个轮询
        this.message[type].forEach(item => {
            // 依次执行每一个消息的回调函数callback
            item(...params)
        })
    }

    // 事件移除
    off(type, callback) {
        // 判断受否订阅，即消息队列里是否有type这个类型的事件，没有的话直接return
        if (!this.message[type]) return
        // 判断是否有callback参数
        if (!callback) {
            // 如果没有callback，就删除整个事件
            // this.message[type] = undefined
            delete this.message[type]
        } else {
            // 如果有callback，就仅仅删掉callback这个消息（过滤掉这个消息方法）
            this.message[type] = this.message[type].filter(item => item !== callback)
        }

    }
    
    // 执行一次
    once(type, callback){
        // 临时创建一个函数，再off销毁
        let dFun = (...args) => {
            callback.apply(this, args)
            this.off(name, dFun)
        }
        this.on(type, dFun)
    }
}
```

## 实现观察者模式

```js
// 被观察者
class Subject {
    constructor() {
        // 观察者队列
        this.obsevers = []
    }
    // 添加观察者
    addObserver(obs) {
        this.obsevers.push(obs)
    }

    // 删除观察者
    removeObserver(obs) {
        let index = this.obsevers.indexOf(obs)
        if (index > -1) {
            this.obsevers.splice(index, 1)
        }
    }

    // 通知观察者
    notifyObserver() {
        this.obsevers.forEach(item => {
            item.update()
        })
    }
}

// 观察者
class Observer {
    constructor(name) {
        this.name = name
    }
    update() {
        console.log('Observer is updated');
    }
}
```

```js
// 测试代码
const subject = new Subject()
const observer1 = new Observer('观察者1')
const observer2 = new Observer('观察者2')

subject.addObserver(observer1)
subject.addObserver(observer2)
console.log(subject)

subject.removeObserver(observer1)
console.log(subject)

subject.notifyObserver()
```

## 实现 add(1)(2)(3)

```js
// 粗暴版
function add(a) {
    return function (b) {
        return function (c) {
            return a + b + c
        }
    }
}
```

```js
// 柯里化
function curry(fn, ...args) {
    return args.length >= fn.length ? fn(...args) : curry.bind(null, fn, ...args)
}
function add1(a, b, c) {
    return a + b + c
}
let add = curry(add1)
console.log(add(1)(2)(3));
```

## 实现并发控制

```js
async function sendRequest(urls, max, callback) {
    let curIndex = 0 // 当前执行索引
    let counter = 0 // 完成的个数
    const len = urls.length
    const results = [] // 结果数组
    async function start() {
        while (curIndex < len && max > 0) {
            max-- // 占用通道
            console.log('start', curIndex)
            const path = urls[curIndex] // 保存路径
            curIndex++
            fetch(path).then(res => res.json()).catch(err => {
                console.log('请求失败', err)
                results.push(err)
            }).then(res => {
                max++ // 释放通道
                counter++
                // 如果为undefined 请求失败 不加入results数组
                if (res) {
                    results.push(res)
                }
                // 完成数和总数相等 执行回调
                if (counter === len) {
                    callback(results)
                } else {
                    start()
                }
            })
        }
    }
    start()
}
```

测试：i =8时为错误用例

```js
const urls = []
for (let i = 1; i <= 20; i++) {
    if (i == 8) {
        urls.push(`123`)
    } else {
        urls.push(`https://jsonplaceholder.typicode.com/todos/${i}`)
    }
}
const maxConcurrentRequests = 3;
sendRequest(urls, maxConcurrentRequests, (results) => {
    console.log('All requests completed.');
    console.log(results)
    // 处理存储在results数组中的结果
})
```

## 实现一个promise 包含all和race方法

## 快排

```js
function quickSort(arr) {
    // 长度小于2直接返回
    if (arr.length < 2) return arr
    // 取中间数
    let pivotIndex = Math.floor(arr.length / 2)
    let pivot = arr.splice(pivotIndex, 1)[0]
    let left = []
    let right = []
    // 遍历小于中间数放到左边数组，大于放右边
    arr.forEach(item => {
        if (item < pivot) left.push(item)
        else right.push(item)
    })
    // 递归遍历
    return quickSort(left).concat([pivot], quickSort(right))
}
```

## 有效的括号

## 开平方根