## 1. tree-shaking是什么，有什么作用，原理是什么

```
tree-shaking可以实现删除项目中未被引用的代码，减少最终打包后的体积。利用es6模块化的静态分析，找到没有引入的模块和变量打上标记，然后在压缩阶段删除没有用到的代码。
```

## 2. babel是什么 原理，怎么做到的

```
babel的转译分为三个阶段，先解析（Parse）将代码解生成抽象语法树（AST）即词法分析与语法分析的过程。然后转换（transform），对AST进行深度优先遍历执行添加、更新删除等操作。最后生成（generate）将变换后的AST再转换成JS代码，
```

## 3. webpack工作流程是怎样的

```
webpack的运行流程是一个串行的过程，从启动到执行会依次执行，先读取配置文件，也就是webpack.config.js，然后解析入口文件及其依赖，构建整个依赖树，再进行模块编译，比如babel进行ES6语法转换，使用css-loader处理css文件，然后根据入口和模块的依赖关系，组装成一个个包含多个模块的Chunk，再把Chunk转换为单独文件输出资源，最后根据配置的输出路径和文件名，把文件内容写入到文件系统中。
总的来说webpack将多个模块进行转换和打包，最终生成一个或多个输出文件。在这个过程中，会进行各种处理和优化，以提高打包效率和输出文件的性能。
```

## 4. webpack热更新机制

```
webpack热更新也叫HMR，这个机制可以做到不用刷新浏览器而将新变更的模块替换旧的模块
HMR的核心是客户端从服务端拉取更新后的文件，准确的说chunk diff（chunk需要更新的部分），实际上WDS（无线路由）与浏览器维护了一个websocket，当本地资源发生变化，WDS会向浏览器推送更新，并带上构建时的hash，让客户端与上一次资源进行对比。客户端对比出差异后向WDS发起ajax请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。
后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。
```

## 5. 是否有写过webpack的loader、插件

```
编写loader要遵循单一原则，一个loader只做一个转义工具。每个loader拿到源文件内容，通过返回值的方式将内容处理后输出，也可调用this.callback()返回给webpack，还可以通过this.async()生成一个回调输出
Plugin在webpack运行的生命周期中会发出许多事件，plugin可以监听这些事件，对产物做出特殊处理
```

## 常见的loader

```
babel-loader：用于将ES6+代码转换为ES5，使它们能够在更多的浏览器中运行。
css-loader：用于解析CSS文件，并将其转换为JavaScript对象。
style-loader：将CSS代码以<style>标签的形式注入到HTML页面中。
file-loader：用于处理图片、字体等静态资源文件，并将它们输出到指定目录。
url-loader：可以像file-loader一样处理静态资源文件，但是对于小文件，可以将其转换为Data URL以减少HTTP请求。
sass-loader：用于编译Sass/Scss文件为CSS文件。
less-loader：用于编译Less文件为CSS文件。
postcss-loader：用于对CSS代码进行后处理，例如自动添加浏览器前缀、压缩等。
```

## 常见的plugin

```
HtmlWebpackPlugin：用于生成HTML文件，并自动引入打包后的资源文件
MiniCssExtractPlugin：用于将CSS文件提取出来，并生成单独的CSS文件
BoundleAnlyzerPlugin：用于分析打包后的模块大小和依赖关系，以便进行优化
CompressionWebpackPlugin：用于压缩构建输出的内容，以减小文件大小，提高加载速度
OptimizeCSSAssetsPlugin：用于压缩CSS代码
UglifyJsPlugin：用于压缩JavaScript代码
CleanWebpackPlugin：用于清空输出目录中的文件
CopyWebpackPlugin：用于将指定的文件或目录复制到输出目录
DefinePlugin：用于定义全局变量
```

##  **bundle**，**chunk**，**module**是什么？

- bundle：是由webpack打包出来的⽂件； 
- chunk：代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并和分割；
- module：是开发中的单个模块，在webpack的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack会从配置的 entry中递归开始找出所有依赖的模块。

## 6. webpack插件机制

```
插件机制是通过在编译流程中发布事件和订阅事件事件实现，作用在webpak整个生命周期，监听某些webpack的事件，对产物做出特殊的处理
```

## 7. 谈下webpack loader机制

```
loader是用于将不同类型的文件转换为模块可执行的js代码，也就是将非js文件转换为js文件，基于node环境先解析在转换
```

## 8. webpack loader和plugin有什么区别

```
两者都是为了扩展webpack的功能。
loader是一个函数，主要是用于文件模块的转换，返回可执行的js代码模块
而plugin作用在整个webpack的生命周期，它会监听某些webpack的事件，对产物做出一些特殊处理，例如代码压缩，tree-shaking，注入一些环境变量
```

## 9. 模块化机制

```
webpack模块化机制通过模块加载器和模块打包器实现。模块加载器用于加载各种类型的文件，比如js、css、图片等，模块打包器则将各个模块打包成一个或多个文件，以便在浏览器上运行。
支持各种模块化规范比如ESM,CJS,AMD等，支持各种文件类型，支持按需加载，支持插件扩展
```

## 10. uglify原理

```
uflify是一个代码压缩工具，可以将js代码压缩为更小的体积，提高网页加载速度和响应事件
主要通过将一些语法结构比如条件语句、循环语句转换为更简洁的形式，还有删除一些未使用的变量和空格换行符，减小代码体积
```

## 你对模块化的理解

```
模块化就是把复杂代码按功能的不同划分成不同的模块单独维护，模块之间可以相互依赖，提高开发效率，降低维护成本
```

## 11. 前端微服务

```
前端微服务是将前端应用程序拆分为多个小型、独立的应用程序，并通过组合这些小型应用程序来构建大型应用程序的一种架构方式。每个小型应用程序都可以独立部署、维护和扩展，这样可以提高应用程序的灵活性和可维护性。
```

## 12. webpack和vite的区别

```
webpack会先打包，然后启动开发服务器，请求服务器时直接给予打包结果。 而vite是直接启动开发服务器，请求哪个模块再对该模块进行实时编译。 由于现代浏览器本身就支持ES Module，会自动向依赖的Module发出请求（对于非esmodule的模块，会用esbuild进行预打包）。
 由于vite在启动的时候不需要打包，也就意味着不需要分析模块的依赖、不需要编译，因此启动速度非常快。当浏览器请求某个模块时，再根据需要对模块内容进行编译。这种按需动态编译的方式，极大的缩减了编译时间，项目越复杂、模块越多，vite的优势越明显。
 在HMR方面，当改动了一个模块后，仅需让浏览器重新请求该模块即可，不像webpack那样需要把该模块的相关依赖模块全部编译一次，效率更高。 当需要打包到生产环境时，vite使用传统的rollup进行打包，因此，vite的主要优势在开发阶段。另外，由于vite利用的是ES Module，因此在代码中不可以使用CommonJS
```

## 13. vite为什么生产环境使用rollup

```
1、vite底层的插件机制是完全兼容rollup的，依赖于rollup，使vite的生态庞大
2、esbuild虽然快，但是他有很多局限性：代码分割，语法降级等不支持
3、rollup对esm的支持非常好，赋予了vite按需打包的能力
```

## git和SVN的区别

```
git是分布式版本控制工具，有本地和远程两个库，svn是集中式，只用一个远程版本库，如果服务器出现问题，svn就无法提交代码；git的分支是指向某次提交，而svn是整个版本库复制的完整目录，开销更大；git可以添加暂存区，提交本地库，推送远程，svn是添加暂存commit直接推送远程库
```

## 项目里的git怎么使用的

```
在工作区开发，添加暂存区，提交本地库，推送远程仓库
```

## git merge和git rebase的区别

```
git merge合并会产生一个新的merge commit，然后将两个分支进行合并，不会对现有的分支造成影响，但会导致历史记录相对复杂

git rebase会将整个分支移动到另一个分支上，整合了所有分支的提交，主要的好处是提交历史记录清晰，消除了git merge所需的不必要的合并提交
```

## git stash

```
git stash会把所有未提交的修改都存储起来，用于恢复当前的工作目录，stash之后，工作目录会变得很干净
当解决完另一个分支的问题之后再切换回stash之后的分支可以用git stash pop或git stash apply恢复之前得到状态
```

肯定不分的，框架只是工程化的一环，核心就是降本提效，就向很多同学认为webpack就是前端工程化，其实他就是一个打包工具，工程化的一环
