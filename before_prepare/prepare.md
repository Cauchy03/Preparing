# 闭包

```
其实就是一个函数访问另一个函数，两个作用：保护和保存
函数执行形成一个私有作用域，不受外部的干扰，适合模块化开发
另一个是保存，当一个函数返回另一个引用数据类型的时，被外界所接收了就会形成不销毁的作用域，一直存储在浏览器里面，容易造成内存泄漏

内存泄漏：浏览器无法回收这个代码的内存

基本数据类型:Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、Symbol、BigInt
引用数据类型:Object
```

# 作用域

```
在 JavaScript 中有两种作用域类型：局部作用域 全局作用域
JavaScript 拥有函数作用域：每个函数创建一个新的作用域。
作用域决定了这些变量的可访问性（可见性）。
函数内部定义的变量从函数外部是不可访问的（不可见的）
```

# 原型链

```
本质是一个链表，当你有一个函数的时候，它会返回一个实例，这个实例会有一个proto属性值，指向它的原型，同时这个函数prototype属性指向这个原型
当访问实例身上的属性时候，如果没有就顺着proto指向的原型上找，原型上也没有，就顺着proto找原型的原型，直到Object的实例，找到的话会把值付给取的这个变量

js特有，所有对象都可以共享原型上面的方法，可以节省内存
```

# `vue`生命周期

```
vue有一般情况下有初始化、挂载、更新和销毁四个生命周期，对应的八个钩子函数
初始化周期的钩子函数包括beforeCreate()和created()，created()在vue中data、methods等里面的数据生成后触发，实际开发中一般会在created()中进行进行获取页面初始数据以及一些静态数据的操作

挂载周期包括deforeMount()和mounted()两个钩子函数，分别表示真实DOM结构挂载之前和挂载触发，实际开发中如果需要在DOM加载之后第一时间对DOM进行操作，一般会在mounted()钩子函数中进行

更新周期包括beforeUpdata()和updated()两个钩子函数，分别表示数据更新之前和数据更新之后触发，但实际开发中一般不会使用这两个函数，因为当数据频繁更新时，每一次数据更新就会触发一次对应的函数，会造成循环，如果需要对数据更新进行监视触发一定的逻辑，可以通过监听器watch来实现

销毁阶段包括beforeDestroy()和destroyed()两个钩子函数，表示vue实例销毁前和销毁后触发的函数，实际开发中一般会在beforeDestroyed()中对定时器、计时器等进行关闭，如果不关闭，当组件销毁后定时器也会继续执行；
```

# `vue`组件通信

```
1:父子组件通信，最常见的使用props和emit，父组件通过props将数据传递给子组件，子组件通过emit触发父组件中的方法来修改数据。其次还可以通过$ref、$parent和$child进行通信。
2:祖孙组件之间的通信:这种通信一般也可以用props和emit只不过逐层传递会很麻烦，可以使用$listener和$attrs来进行通信。
3:兄弟组件之间的通信:可以创建eventBus事件总线，通过$emit和$on的方式进行通信。其次还有全局数据通信，我们可以使用Vuex作为全局状态管理来实现
```

# `vue`双向绑定

```
通过数据劫持Object.defineProperty+发布订阅者模式，当vue实例初始化后observer会针对实例中的data中的每一个属性进行劫持并通过defineProperty()设置值后在get（）中向发布者添加该属性的订阅者,这里在编译模板时就会初始化每一属性的watcher，在数据发生更新后调用set时会通知发布者notify通知对应的订阅者做出数据更新，同时将新的数据根性到视图上显示。缺陷：只能够监听初始化实例中的data数据，动态添加值不能响应，要使用对应的Vue.set()。
```

# `vue`指令

v-bind

描述：绑定dom属性，绑定表达式与dom属性

语法：`v-bind:属性="表达式"` or `:属性="表达式"`

v-on

描述：绑定事件，监听dom上的事件，并绑定回调函数

语法：`v-on:事件名="回调函数"` or `@事件名="回调函数"`。事件绑定指令的表达式一般是回调函数，且该函数接受一个参数`$event`。当绑定的事件被触发就会执行绑定的函数

v-if

描述：dom元素显示判断，当表达式为真的时候，显示dom元素，否则销毁dom

语法：`v-if="表达式"`。只要表达式不一定必须是true，只要能判断为真即显示dom元素

v-show

描述：dom元素显示判断，当表达式为真的时候，显示dom元素，否则隐藏dom。 看到这里，是不是发现和v-if很相似呢？从功能上看是的，但从实现原理来说这两个则完全不同，这个我们后面在讨论。

语法：`v-show="show"`

v-model

描述：数据双向绑定，这个指令多用于需要绑定值和修改值的操作，比如输入框

语法：`v-model="value"`

v-for

描述：用于循环列表。v-for指令最基本的功能就是用于渲染一些样式相对重复的dom，最常使用的就是列表

语法：`v-for="item in list" :key="item.id"`。v-for指令的表达式与普通表达不同，它基本是确定的，list是需要循环的数组，item则是list遍历的子元素。且不同其他指令，v-for还要搭配key来使用，这主要是为了做唯一标识的作用。item和list都是可以自定义的。比如你也可以写成`v-for="data in datas" :key="data.id"`。

# 防抖节流

```
在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。

防抖：前面的所有的触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发,只会执行最后一次  	 *(就是回城,被打断就要重新来)*

节流：在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发 			 *(就是技能CD,CD没好,你用不了技能)*
```

# 默认事件

```
默认事件：就是浏览器通过HTML标签或DOM元素提供的一些功能性的默认行为。比如在a标签href属性上的跳转，右键呼出的菜单，submit表单提交事件等等。我们可以通过js取消或更改这些默认事件

默认事件都是定义在DOM元素相应的事件类型上的，我们只需要知道产生默认事件的是哪个元素，这个事件是什么类型的，就可以阻止或修改它。实现方式就是注册相应的事件处理函数，在其中通过如下API阻止默认事件的发生。

event.preventDefault() 
```

# 事件冒泡

```
在一个对象上触发某类事件（比如点击事件），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）

event.stopPropagation()
```

# 数组常用方法

```
push(),pop(),shift(),unshift(),splice(),sort(),reverse()
forEach,fliter,map,some,every
```

# 数组去重

[JavaScript 数组去重的方法（12 种方法，史上最全） - 前端开发随笔 - SegmentFault 思否](https://segmentfault.com/a/1190000016418021)

# 字符串操作方法

![image-20230109123901919](C:\Users\Cauchy\AppData\Roaming\Typora\typora-user-images\image-20230109123901919.png)

# 清除浮动

```
# 浮动（float）

**定义：**
css浮动是一种使元素脱离普通标准流控制的方法，元素会根据float的值向左或向右移动，直到它的外边界碰到父元素的内边界或另一个浮动元素的外边界为止，其周围的元素也会重新排列。浮动是一种非常有用的布局方式，能够改变页面中对象的前后流动顺序。

我们要知道：浮动的框可以左右移动，直到遇到另一个浮动框或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。
此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。
浮动的弊端

由于浮动元素脱离了文档流，所以父元素的高度无法被撑开，影响了与父元素同级的元素
与浮动元素同级的非浮动元素会跟随其后，因为浮动元素脱离文档流不占据原来的位置
如果该浮动元素不是第一个浮动元素，则该元素之前的元素也需要浮动，否则容易影响页面的结构显示
```

[css清除浮动 - 掘金 (juejin.cn)](https://juejin.cn/post/7139106039424614414#heading-3)

# 什么时候用padding和margin

```
同级盒子用margin，父子盒子用padding，如果父子用margin容易造成margin塌陷问题
```

```
解决margin塌陷
overflow: hidden
```

# BFC

```
当我们产生一个bfc的时候，它就会按照bfc的这个块级格式化上下文规则去渲染页面，和html的渲染时分开的，它不存在margin塌陷，所以就可以解决margin塌陷问题
```

# 盒模型

```
所谓盒子模型（Box Model）就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都是由元素的内容（content）、内边距（padding）、边框（border）和外边距（margin）组成。
所有的文档元素（标签）都会生成一个矩形框，我们称为元素框，它描述了一个文档元素在网页布局汇总所占的位置大小。每个盒子除了有自己的大小和位置外，还影响着其他盒子的大小和位置，因此正确了解css盒子模型对我们前端页面布局十分重要。
css的盒子模型包括标准盒子模型和IE盒子模型（怪异模型）

标准盒子模型
width就是content的内容，盒子的宽度是 content + padiing + border
IE盒子模型
width是content + padding + border这是三部分的宽度，盒子的宽度就是width

css3中引入了box-sizing属性，box-sizing:content-box 表示标准盒子模型，box-sizing:border-box 表示IE盒子模型
```

# div垂直居中

```
利用position：absolute的特性
先设置元素的top、left偏离50%，再用margin让位置往回一半。

设置margin为auto

transform translate(50%, 50%)

flex align-items: center;
    justify-content: center;
```

[CSS垂直居中的12种实现方式 - 掘金 (juejin.cn)](https://juejin.cn/post/6844903550909153287)

# 两个异步请求数据操作怎么合并

```
因为 await 后面必须跟一个 Promise 实例，可以用Promise.all() 这个方法把多个 Promise 实例合并成一个 Promise 实例。Promise.all() 接收一个部署了 Iterator 的对象（例如：数组、Set），每个成员都必须是 Promise 实例，且只有当每个成员的状态都是 fulfilled 的时候，总实例的状态才是 fulfilled，否则是 rejected
```

# v-model是谁的语法糖

[(36条消息) 如何理解v-model的实质为语法糖_Ruonorth的博客-CSDN博客](https://blog.csdn.net/riddle1981/article/details/74856816)

# async和await解决什么问题

```
async/await 是ECMAScript7提出来解决异步问题的方案，这个要比ES6的promise使用起来更清晰，更方便。

用法：
在JavaScript里的函数前面加上async关键字，则这个函数的返回结果就会变成一个Promise对象。
await必须放在async函数里
在await后面接一个函数，来等待这个函数执行完成，如果这个函数返回的是Promise，则等待这个函数里异步结果执行完成(resolve())后再继续往下执行；如果返回的是非Promise，则函数里面的代码执行完就返回，不管有没有异步的结果。
```

# let和const的区别

```
1、let和const的相同点：
①　只在声明所在的块级作用域内有效。
②　不提升，同时存在暂时性死区，只能在声明的位置后面使用。
③　不可重复声明。

2、let和const的不同点：
①　let声明的变量可以改变，值和类型都可以改变；const声明的常量不可以改变，这意味着，const一旦声明，就必须立即初始化，不能以后再赋值。
```

# 常见的状态码

```
 状态码的职责是当客户端向服务器发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求还是出现了错误
```

![image-20230109130844823](C:\Users\Cauchy\AppData\Roaming\Typora\typora-user-images\image-20230109130844823.png)

# 常见的宏任务微任务

```
宏任务（task）：就是JS 内部（任务队列里）的任务，严格按照时间顺序压栈和执行。如 setTimeOut、setInverter、setImmediate 、 MessageChannel等

微任务（Microtask ）：通常来说就是需要在当前 任务 执行结束后立即执行的任务，例如需要对一系列的任务做出回应，或者是需要异步的执行任务而又不需要分配一个新的 任务 ，这样便可以减小一点性能的开销。
```

[(36条消息) JS 微任务和宏任务(面试题常用)_@星城的博客-CSDN博客](https://blog.csdn.net/qq_44624386/article/details/107344664)

# 怎么判断两个数组是否相等

```
第一种方法，挨个遍历
第二种方法，可以将他们都转换成字符串进行比较
```

# 前端怎么给数据加密

```
base64加解密方式及其原理
MD5加密(不可逆)
编码和解码字符串 主要是使用JS函数的escape()和unescape()，分别是编码和解码字符串
```

# 两个html文件怎么传值

```
get方式，url携带参数
可以通过window.location.search获取url上的参数
通过cookie，传递cookie能够存储少量数据到客户端的磁盘中，特定的网页之间是可以共享cookie中的数据
window.open和window.opener之间传值
h5技术，window.localStorage存储数据
```

[(36条消息) 两个HTML页面之间如何传值_小瑾沐晚风的博客-CSDN博客_html两个页面传值按钮](https://blog.csdn.net/xiaojinguniang/article/details/83864992)

# 用户输入url地址会发生什么

```
首先会进行一个DNS解析，就是把你输入的网址转成对应的ip地址，然后进行TCP的建立，这时候看是http还是https，如果是https的话，它还会有一个SSR套阶层，主要是为了安全，然后会进行三次握手四次挥手，具体四次挥手的时间，看你是否设置keep alive属性，若没有设置，所有的请求都会进行三次握手四次挥手，会非常浪费时间，但是从http1.0之后，所有都会默认加keep alive属性，然后当我们所有访问http请求之后它才进行这个四次挥手，所有的数据都会进行网络五层模型，然后拉数据，如果单页面开发，他会首先拉html文档，然后从上到下加载资源，当加载到html的时候，它会生成dom，当加载css的时候会进行css tree，css tree和dom tree会同步解析，但是如果碰到js的话，不论是js的下载还是解析，它都会阻塞整个html文件的渲染，那js内部执行又分为同步任务和异步任务，同步任务就是从上到下执行，碰到异步任务，它会放到队列里面，按照队列里面按照顺序执行，异步任务又分为宏任务和微任务，像promise就是微任务
```

# js设计模式

```
构造函数设计模式
原型模式
模块设计模式
单例模式
```

[开发人员都应该了解的7种JavaScript设计模式_前端_Deven_InfoQ精选文章](https://www.infoq.cn/article/jUDjSPGGcZx7FKKhWUcc)