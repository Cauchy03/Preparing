## 移动端适配

```
首先是这个媒体查询，会根据不同的屏幕尺寸大小显示不同css样式，但没多一个屏幕尺寸，就会多一个@media查询块，主要用于一些极端情况，比如ipad大屏或一些简单的适配。
然后是这个rem适配，rem是一个相对单位，相对于根元素的font-size的值，flexible.js一个阿里早期的开源移动适配库，就是采用rem通过js模拟vw的特性进行适配，但是rem和根元素font-size的值强耦合，系统字体大小放大或缩小的时候可能会导致布局错乱。
然后是vw/vh适配，相对单位，根据可视化窗口的百分占比，但与%又有所区别，%相对于父元素，而vw/vh相对于可视化窗口，主要就是兼容性的问题。可以通过 postcss-px-to-viewport 插件，将px自动转为vw/vh
```

## RBAC权限管理

```
RBAC意为基于角色的权限控制，是一个权限设计思想，也就是说根据不同的用户角色，有不同的权限控制。

给员工配置角色 （一个员工可以拥有多个角色）
给角色配置权限点 （一个角色可以有多个权限点）
员工只要有了角色之后，就自动拥有了角色绑定的所有权限点
```

根据权限设计思想对应业务模块

- 员工管理
- 角色管理
- 权限点管理（它是没有调整的余地的：它会严格与当前系统的功能对应！）

### 菜单权限管理

```
将路由分为常量路由也就是共享路由，异步路由涉及权限的路由，在meta标签中设置一个routeID，根据返回回来的路由表进行一个匹配查询，最后将常量路由和异步路由进行一个合并，在通过router.addroutes()添加最终的路由。将最终的路由存在vuex中，然后动态渲染左侧的菜单
```

```js
// 计算异步路由属性
function computeRoutes(asyncRoutes, routes) {
    return asyncRoutes.filter(item => {
        // 判断一级路由
        if (routes.indexOf(item.name) !== -1) {
            // 递归 遍历子路由
            if (item.children && item.children.length) {
                item.children = computeRoutes(item.children, routes)
            }
            return true
        }
    })
}
```

```js
state.resultAsyncRoutes = asyncRoutes
// 只包含异步路由，还需合并常量路由和任意路由
state.resultRoutes = constantRoutes.concat(state.resultAsyncRoutes, anyRoutes)
// router添加路由
router.addRoutes(state.resultRoutes)
```

### 页面中控制按钮权限

```js
// 设置一个自定义指令 v-allow
// 注册一个全局自定义指令 `v-allow`
Vue.directive('allow', {
    inserted: function(el, binding) {
        // 从vuex中取出points,
        const points = store.state.user.userInfo.roles.points
        // 如果points有binding.value则显示
        if (points.includes(binding.value)) {
            // console.log('判断这个元素是否会显示', el, binding.value)
        } else {
            el.parentNode.removeChild(el)
            // el.style.display = 'none'
        }
    }
})
```

```html
<el-button
           v-allow="'import_employee'"
           type="warning"
           size="small"
           @click="$router.push('/import')"
           >导入excel</el-button>
```

### 一些BUG

#### 刷新页面时出现404

动态添加路由后 404的位置不是路由的末尾了 把404页面改到最末尾

从route/index.js中的静态路由中删除`path:'*'`这一项

```js
// 不需要特殊的权限控制就可以访问的页面
export const constantRoutes = [
    {
        path: '/login',
        component: () => import('@/views/login/index'),
        hidden: true
    },
    // 404 page must be placed at the end !!!
    { path: '*', redirect: '/404', hidden: true }
]
```

在路由守卫中最后添加到过滤的路由数组中

```js
if (!store.getters.userId) {
    // ....
    const filterRoutes = asyncRoutes.filter(route => {
        const routeName = route.children[0].name
        return menus.includes(routeName)
    })

    // 一定要在进入主页之前去获取用户信息
    // 把404加到最后一条
    filterRoutes.push( // 404 page must be placed at the end !!!
        { path: '*', redirect: '/404', hidden: true })

    // addRoutes用来动态添加路由配置
    // 只有在这里设置了补充了路由配置，才可能去访问页面
    // 它们不会出现左侧
    router.addRoutes(filterRoutes)
    // ...
} 
```

#### 对于addRoutes添加的路由，在刷新时会白屏

在`addRoutes()`之后第一次访问被添加的路由会白屏，这是因为刚刚`addRoutes()`就立刻访问被添加的路由，然而此时`addRoutes()`没有执行结束，因而找不到刚刚被添加的路由导致白屏。因此需要从新访问一次路由才行。

```js
if (!store.getters.userId) {
    // 省略其他...

    // 解决刷新出现的白屏bug
    next({
        ...to, // next({ ...to })的目的,是保证路由添加完了再进入页面 (可以理解为重进一次)
        replace: true // 重进一次, 不保留重复历史
    })
} else {
    next()
}
```

[(7条消息) VUE 路由守卫 next() / next({ ...to, replace: true }) / next(‘/‘) 说明_Incimo的博客-CSDN博客](https://blog.csdn.net/qq_41912398/article/details/109231418?spm=1001.2014.3001.5506)

#### 退出登录时重置路由

退出后，再次登陆，发现菜单异常 （控制台有输出说路由重复）

![img](https://img-blog.csdnimg.cn/20210706024556428.png)

原因:

路由设置是通过`router.addRoutes(filterRoutes)`来添加的，退出时，并没有清空，再次登陆，又加了一次，所以有重复。

需要将路由权限重置 (恢复默认) 将来登录后再次追加才可以，不然的话，就会重复添加

在router/index.js中定义一个方法 这个方法将路由重新实例化

```js
// 重置路由
export function resetRouter() {
    const newRouter = createRouter()
    router.matcher = newRouter.matcher // 重新设置路由的可匹配路径
}
```

退出的时候调用这个方法

```js
import { resetRouter } from '@/router'
// 退出的action操作
logout(context) {
    // 1. 移除vuex个人信息
    context.commit('removeUserInfo')
    // 2. 移除token信息
    context.commit('removeToken')
    // 3. 重置路由
    resetRouter()
}
```

## axios具体封装

```js
// 创建一个实例
const service = axios.create({
    baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url
    // withCredentials: true, // 当跨域请求时发送cookie
    timeout: 5000 // request timeout
})

// 请求拦截器
service.interceptors.request.use(config => {
    if (store.getters.token) {
        // 如果携带token 在响应头设置(与后端商量)  
        config.headers['token'] = getToken()
    }
    return config
}, error => {
    console.log(error)
    return Promise.reject(error)
})

// 响应拦截器
service.interceptors.response.use(
    /**
   * 如果你想获取http信息，如请求头或状态
   * 可以return  response => response
  */
    /**
   * 通过自定义代码确定请求状态
   * 也可以通过HTTP状态码来判断状态
   */
    response => {
        const res = response.data
        // 服务器响应失败的回调 code的值可能是200也可能20000
        if (res.code !== 20000 && res.code !== 200) {
            Message({
                message: res.message || 'Error',
                type: 'error',
                duration: 5 * 1000
            })

            // 50008: 非法的token; 50012: 已登录的其他客户端; 50014: token过期;
            if (res.code === 50008 || res.code === 50012 || res.code === 50014) {
                // 重新登录
                // You have been logged out, you can cancel to stay on this page, or log in again
                MessageBox.confirm('您已登出，您可以取消以留在此页面，或重新登录', '确认注销', {
                    confirmButtonText: '重新登录',
                    cancelButtonText: '取消',
                    type: 'warning'
                }).then(() => {
                    store.dispatch('user/resetToken').then(() => {
                        location.reload()
                    })
                })
            }
            return Promise.reject(new Error(res.message || 'Error'))
        } else {
            // 相应成功的回调
            return res
        }
    },
    error => {
        console.log('err' + error) // for debug
        Message({
            message: error.message,
            type: 'error',
            duration: 5 * 1000
        })
        return Promise.reject(error)
    }
)
```

### 用过fetch吗?fetch和axios的区别知道吗?

**1、最大的不同:**

**最大的不同点在于Fetch是浏览器原生支持，而Axios需要引入Axios库。**

**2、兼容性方面**

Axios可以兼容IE浏览器，而**Fetch在IE浏览器和一些老版本浏览器上没有受到支持**，但是有一个库可以让老版本浏览器支持Fetch即它就是whatwg-fetch，它可以让你在老版本的浏览器中也可以使用Fetch，并且现在很多网站的开发都为了减少成本而选择不再兼容IE浏览器。

**3、响应超时**

Axios的相应超时设置是非常简单的，直接设置timeout属性就可以了，而Fetch设置起来就远比Axios麻烦，这也是很多人更喜欢Axios而不太喜欢Fetch的原因之一。

**4、对数据的转换**

Axios还有非常好的一点就是会自动对数据进行转化，而Fetch则不同，它需要使用者进行手动转化。

**5、拦截器**

Fetch没有拦截器功能，但是要实现该功能并不难，直接重写全局Fetch方法就可以办到。